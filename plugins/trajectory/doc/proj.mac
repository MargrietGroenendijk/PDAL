/* Reformulate ray error as projection */

/* Let pv = [px,py,pz] be unit vector from midpoint of returns to first
return and pa be the distance */

/* z x pv = [py, -px, 0]
 angle = asin(sqrt(px^2+py^2)),
 direction = [py, -px, 0]/sqrt(px^2+py^2)
 rotation = asin(sqrt(px^2+py^2)) * [py, -px, 0]/sqrt(px^2+py^2)

 */

rot:asin(sqrt(px^2+py^2)) * [py, -px, 0]/sqrt(px^2+py^2)$

rottoquat(rot):=block(
[  theta : sqrt(rot.rot), s, c],
s: sin(theta/2)/theta,
[cos(theta/2), s*rot[1], s*rot[2], s*rot[3]])$

q:rottoquat(rot);

/* Quaternion [pz, py, -px, 0] rotates pv to [0, 0, 1] */
/* convert to matrix */
quattomat(q):=block([m:ident(3)],
  m[1,1] : q[1]*q[1]+q[2]*q[2]-q[3]*q[3]-q[4]*q[4],
  m[1,2] : 2*(q[2]*q[3]-q[1]*q[4]),
  m[1,3] : 2*(q[2]*q[4]+q[1]*q[3]),
  m[2,1] : 2*(q[2]*q[3]+q[1]*q[4]),
  m[2,2] : q[1]*q[1]+q[3]*q[3]-q[2]*q[2]-q[4]*q[4],
  m[2,3] : 2*(q[3]*q[4]-q[1]*q[2]),
  m[3,1] : 2*(q[2]*q[4]-q[1]*q[3]),
  m[3,2] : 2*(q[3]*q[4]+q[1]*q[2]),
  m[3,3] : q[1]*q[1]+q[4]*q[4]-q[2]*q[2]-q[3]*q[3],
  m)$
M:quattomat(q);
/* After simplification ... */

M:block([p2:px^2+py^2],
matrix([(px^2 * pz + py^2) / p2, -(1 - pz) * px * py / p2, -px],
       [-(1 - pz) * px * py / p2, (px^2 + py^2 * pz) / p2, -py],
       [ px, py, pz]))$

/* If r is vector from midpoint to platform, then
  s = M.r rotates this to new coordinate system.
  [sx,sy]*pa/sz project platform onto perp plane at first return */

rotx(t):=matrix([     1 ,     0,      0 ],
                [     0 , cos(t),-sin(t)],
                [     0 , sin(t), cos(t)])$
roty(t):=matrix([ cos(t),     0 , sin(t)],
                [     0 ,     1 ,     0 ],
                [-sin(t),     0 , cos(t)])$
rotz(t):=matrix([ cos(t),-sin(t),     0 ],
                [ sin(t), cos(t),     0 ],
                [     0,      0 ,     1 ])$

/* start with platform level, pointing in the y direction (N), and with
   the laser down and apply scan (-y) + roll(y) + pitch(x) + heading(-z) to
   give the final pulse direction as

f approx rotz(-heading) . rotx(pitch) . roty(roll-scan)
   . transpose([0,0,-1]);

N.B. scan angle is defined a neg/pos on left/right side of platform

Applying the reverse rotations gives

transpose([0,0,-1]) approx roty(scan-roll) . rotx(-pitch) . rotz(heading) . f

use x and y components of this vector as the residue

*/
